#import "PAT.Lib.Tookit";

// The functions of "extend" and "calculate price" operations have not been implemented, currently they are used as EXTEND and CALCULATED_PRICE
// The process of encrypt and decrypt have not been implemented

enum{PowerSupplier, request, publicKey, privateKey, usageQuery, usageInfo, PS_nonce, attacker_nonce, TPMquote, oldHash, operation};

channel c1 0;                         // channel between Power Supplier and TRE
channel c2 0;                         // channel between TRE and TPM
channel c3 0;                         // channel for communication for hash value

var realQuote;
var quoteMatch = false;
var price;
var hashValue;

// var PowerSupplier_TRE_connection = 0; // 0 represents connection not built, 1 represents connection built
// var TRE_TPM_connection = 0; 
var TPMAccept = 0;                       // 0 represents deny the query, 1 represents accept the query

// Process of Power Supplier, it consists of three events:

// Firstly, it connects TRE
PowerSupplierProc() = PowerSupplierConnectTRE();

PowerSupplierConnectTRE() = 
	c1!PowerSupplier.request -> 
	c1!PS_nonce ->
	PowerSupplierConnected();
	
PowerSupplierConnected() = 	c1?publicKey -> QueryPrice(publicKey);

// Secondly, it sends query of price
QueryPrice(pubk) = 
	c1!usageQuery ->             // **** Need to encrypt using pubk ****
	(c1?TPMquote -> 
	PowerSupplierVerifyQuote(TPMquote, 2) []
	c1?priceEncrypted ->         // **** Need to decrypt using pubk ****;
	c1?TPMquote -> 
	PowerSupplierVerifyQuote(TPMquote, 1));

// Thirdly, end connection	
PowerSupplierVerifyQuote(quote, x) = 
	if(x == 1)  //TRE rejects the request from PowerSupplier
	{	
		// PS_nonce -> 9, seal -> 1, accept -> 2, calculate_add -> 3, calculate_multiply -> 4
		calculateQuote{realQuote = call(HashFunction1, 9, 1, 2, 3, 4);} ->
		if(quote == realQuote)
		{
			powerSupplierDisconnectTRE{quoteMatch = true;} ->
			PowerSupplierDisconnectTRE()
		}
		else
		{
			Skip
		}
	}
	else  //TRE rejects the request from PowerSupplier
	{
		// PS_nonce -> 9, seal -> 1, reject -> 5
		calculateQuote{realQuote = call(HashFunction2, 9, 1, 5);} ->
		if(quote == realQuote)
		{
			powerSupplierDisconnectTRE{quoteMatch = true;} ->
			PowerSupplierDisconnectTRE()
		}
		else
		{
			Skip
		}
	};

PowerSupplierDisconnectTRE() = 
	Skip;

	
// ---------------------------

// Process of TRE, it consists of three events
TREProc() = TREConnect();

// Firstly, connecting to Power Supplier and TPM
TREConnect() = 
	c1?x.request ->			         	// receive request from Power Supplier
	c1?PS_nonce ->				        // receive nonce from Power Supplier
	//extendOperation{hashValue = call(Extend, 0, 9);} ->  			// extend nonce
	c2!9 ->
	c2?publicKey ->
	//extendOperation{hashValue = call(Extend, hashValue, 1);} -> 				// extend seal
	c2!1 ->
	c1!publicKey -> 
	TREConnected(x);

TREConnected(x) = 
	if(x == PowerSupplier){
		c1?usageQuery -> 
		TREResponseUsageQuery(1)
	}
	
	else{
		c1?usageQuery -> 
		TREResponseUsageQuery(0)
	};
	

// Secondly, respond the usage query
TREResponseUsageQuery(accept) =
	if (accept == 1){
		// extendOperation{hashValue = call(Extend, hashValue, 2);} ->                    // extend accept
//		c2!2 ->
		c2!usageQuery ->                // send usage query to TPM
		c2?usageInfo ->                 // get usage info from TPM (encrypted)
		// extendOperation{hashValue = call(Extend, hashValue, 3);} ->                    // extend calculate_add
//		c2!3 ->
		// extendOperation{hashValue = call(Extend, hashValue, 4);} ->                    // extend calculate_multiply
//		c2!4 ->
		calculatePrice{price = call(CalculatePrice, usageInfo);} ->    // calculate the price 
		TREDisconnect()
	}
	else{
		// extendOperation{hashValue = call(Extend, hashValue, 5);} ->                     // extend(reject)
//		c2!5 ->
		TREDisconnect() 				
	};
	
	

// Thirdly, finish the service and disconnect
TREDisconnect() = 
	c2?TPMquote ->
	c1!TPMquote ->
	Skip;
	
	
	
// ---------------------------

// Process of TPM. Since most of TPM job is receiving the extend and prepare keys, these parts are not complete
TPM() = TPMConnect();

TPMConnect() =  
	// ...
	// prepare keys, not implemented yet
	// ...
	c2!publicKey ->                     // send public key
	// extend nonce
	c2?operation ->
	extendOperation{hashValue = call(Extend, 0, operation);} ->
	// extend seal
	c2?operation ->
	extendOperation{hashValue = call(Extend, hashValue, operation);} ->
	TPMResponseUsageQuery();
	
TPMResponseUsageQuery() = 
	if(TPMAccept == 1){
		c2?usageInfo ->                 // **** Need to encrypt using private key ****
		
//		// extend accept
//		c2?operation ->
//		extendOperation{hashValue = call(Extend, hashValue, operation);} ->
//		// extend calculate_add ->
//		c2?operation ->
//		extendOperation{hashValue = call(Extend, hashValue, operation);} ->
//		// extend calculate_multiply
//		c2?operation ->
//		extendOperation{hashValue = call(Extend, hashValue, operation);} ->
		TPMEnd()
	}
	
	else{
		// extebd reject
//		c2?operation ->
//		extendOperation{hashValue = call(Extend, hashValue, operation);}  ->
		TPMEnd()
	};
	
// TPM end service
TPMEnd() = c2!TPMquote -> Skip;
	
Protocol = PowerSupplierProc() ||| TREProc() ||| TPM();

#assert Protocol deadlockfree;